diff --git a/kalshi_client.py b/kalshi_client.py
index d4f7e81..c83597e 100644
--- a/kalshi_client.py
+++ b/kalshi_client.py
@@ -4,6 +4,7 @@ import asyncio
 import logging
 import random
 from datetime import datetime
+from typing import Dict, Optional
 from dotenv import load_dotenv
 
 load_dotenv() # Load variables from .env
@@ -42,7 +43,11 @@ class KalshiClient:
         if self.private_key_path:
             try:
                 with open(self.private_key_path, "r") as f:
-                    self.private_key_content = f.read().strip()
+                    content = f.read().strip()
+                    # Add PEM headers if missing
+                    if not content.startswith("-----BEGIN"):
+                        content = "-----BEGIN RSA PRIVATE KEY-----\n" + content + "\n-----END RSA PRIVATE KEY-----"
+                    self.private_key_content = content
             except FileNotFoundError:
                 logger.error(f"Private key file not found: {self.private_key_path}")
 
@@ -63,7 +68,7 @@ class KalshiClient:
 
         if not self.use_mock:
             if self.env == "prod":
-                self.host = "https://api.kalshi.com/trade-api/v2"
+                self.host = "https://api.elections.kalshi.com/trade-api/v2"
             else:
                 self.host = "https://demo-api.kalshi.co/trade-api/v2"
 
@@ -72,15 +77,20 @@ class KalshiClient:
             
             self.api_client = ApiClient(self.config)
             
+            # Initialize the API instances
+            self.market_api = MarketApi(self.api_client)
+            self.exchange_api = ExchangeApi(self.api_client)
+            
             # Setup RSA Auth if keys are present
             if has_rsa_creds:
                 try:
                     from kalshi_python_async import KalshiAuth
-                    # SDK set_kalshi_auth is broken (NameError + expects path but KalshiAuth wants PEM)
-                    # So we manually instantiate KalshiAuth with the PEM content string
-                    
-                    # Strip indentation from the hardcoded key
-                    # Triple quotes include the indentation which breaks PEM parsing
+                    # Manual signing for websockets
+                    from cryptography.hazmat.primitives import hashes
+                    from cryptography.hazmat.primitives.asymmetric import padding
+                    from cryptography.hazmat.primitives import serialization
+                    import base64
+
                     clean_key = "\n".join([line.strip() for line in self.private_key_content.split("\n") if line.strip()])
                     
                     auth = KalshiAuth(
@@ -88,18 +98,46 @@ class KalshiClient:
                         private_key_pem=clean_key
                     )
                     self.api_client.kalshi_auth = auth
-                    logger.info("Configured RSA Authentication (Manual Workaround).")
+                    logger.info("Configured RSA Authentication.")
                 except Exception as e:
                     logger.error(f"Failed to configure RSA Auth: {e}")
                     self.use_mock = True
 
-            self.market_api = MarketApi(self.api_client)
-            self.exchange_api = ExchangeApi(self.api_client)
-            try:
-                from kalshi_python_async import SearchApi
-                self.search_api = SearchApi(self.api_client)
-            except ImportError:
-                self.search_api = None
+    def get_auth_headers(self, method: str, path: str) -> Dict[str, str]:
+        """Generate Kalshi V2 authentication headers."""
+        if self.use_mock or not self.api_key or not self.private_key_content:
+            return {}
+        
+        from cryptography.hazmat.primitives import hashes
+        from cryptography.hazmat.primitives.asymmetric import padding
+        from cryptography.hazmat.primitives import serialization
+        import base64
+        import time
+
+        timestamp = str(int(time.time() * 1000))
+        msg = timestamp + method + path
+        
+        try:
+            private_key = serialization.load_pem_private_key(
+                self.private_key_content.encode(),
+                password=None
+            )
+            signature = private_key.sign(
+                msg.encode(),
+                padding.PSS(
+                    mgf=padding.MGF1(hashes.SHA256()),
+                    salt_length=padding.PSS.DIGEST_LENGTH
+                ),
+                hashes.SHA256()
+            )
+            return {
+                "KALSHI-ACCESS-KEY": self.api_key,
+                "KALSHI-ACCESS-SIGNATURE": base64.b64encode(signature).decode(),
+                "KALSHI-ACCESS-TIMESTAMP": timestamp
+            }
+        except Exception as e:
+            logger.error(f"Error signing headers: {e}")
+            return {}
 
     async def login(self):
         if self.use_mock:
diff --git a/live_engine.py b/live_engine.py
index 1ddbbc0..a7ff55e 100644
--- a/live_engine.py
+++ b/live_engine.py
@@ -2,6 +2,7 @@ import asyncio
 import json
 import logging
 import time
+import ast
 from typing import Dict, List, Optional, Callable, Any
 from dataclasses import dataclass
 
@@ -22,8 +23,8 @@ class ConnectionStatus:
 
 
 class LiveEngine:
-    KALSHI_WSS_DEMO = "wss://demo-api.kalshi.co/trade-api/v2/ws"
-    KALSHI_WSS_PROD = "wss://api.kalshi.com/trade-api/v2/ws"
+    KALSHI_WSS_DEMO = "wss://demo-api.kalshi.co/trade-api/ws/v2"
+    KALSHI_WSS_PROD = "wss://api.elections.kalshi.com/trade-api/ws/v2"
     POLY_WSS = "wss://ws-subscriptions-clob.polymarket.com/ws/market"
     
     POLY_API = "https://clob.polymarket.com"
@@ -34,12 +35,14 @@ class LiveEngine:
         store: UnifiedStore,
         kalshi_env: str = "demo",
         kalshi_api_key: Optional[str] = None,
-        kalshi_private_key: Optional[str] = None
+        kalshi_private_key: Optional[str] = None,
+        kalshi_client: Any = None
     ):
         self.store = store
         self.kalshi_env = kalshi_env
         self.kalshi_api_key = kalshi_api_key
         self.kalshi_private_key = kalshi_private_key
+        self.kalshi_client = kalshi_client
         
         self._running = False
         self._tasks: List[asyncio.Task] = []
@@ -56,8 +59,9 @@ class LiveEngine:
     def add_status_callback(self, callback: Callable):
         self._status_callbacks.append(callback)
         
+    def add_price_callback(self, callback: Callable):
         self._price_callbacks.append(callback)
-        
+
     def add_raw_callback(self, callback: Callable):
         self._raw_callbacks.append(callback)
         
@@ -125,12 +129,11 @@ class LiveEngine:
         url = self.KALSHI_WSS_PROD if self.kalshi_env == "prod" else self.KALSHI_WSS_DEMO
         
         headers = {}
-        if self.kalshi_api_key and self.kalshi_private_key:
-            import base64
-            auth_value = base64.b64encode(
-                f"{self.kalshi_api_key}:{self.kalshi_private_key[:20]}".encode()
-            ).decode()
-            headers["Authorization"] = f"Basic {auth_value}"
+        if self.kalshi_client and self.kalshi_client.api_key and self.kalshi_client.private_key_content:
+            try:
+                headers = self.kalshi_client.get_auth_headers("GET", "/trade-api/ws/v2")
+            except Exception:
+                pass
         
         kwargs = {}
         if headers:
@@ -138,15 +141,18 @@ class LiveEngine:
             
         while self._running:
             try:
+                logger.info(f"Connecting to Kalshi: {url}")
                 async with websockets.connect(url, **kwargs) as ws:
                     self.kalshi_status.connected = True
                     self.kalshi_status.last_heartbeat = time.time()
                     await self._notify_status(self.kalshi_status)
                     
                     await ws.send(json.dumps({
-                        "type": "subscribe",
-                        "channel": "markets",
-                        "markets": ["*"]
+                        "id": int(time.time()),
+                        "cmd": "subscribe",
+                        "params": {
+                            "channels": ["ticker", "trade"]
+                        }
                     }))
                     
                     async for message in ws:
@@ -154,19 +160,32 @@ class LiveEngine:
                             break
                             
                         try:
+                            # Handle bytes message
+                            if isinstance(message, bytes):
+                                message = message.decode('utf-8')
+                            
                             # Forward raw message
                             await self._notify_raw("kalshi", message)
                             
                             data = json.loads(message)
                             self.kalshi_status.messages_received += 1
                             
-                            if isinstance(data, list):
-                                for item in data:
+                            msg_type = data.get("type", "")
+                            
+                            # Skip subscription confirmations and heartbeats
+                            if msg_type in ["subscribed", "heartbeat"]:
+                                continue
+                            
+                            # Handle message in msg field for new format
+                            msg_data = data.get("msg", data)
+                            
+                            if isinstance(msg_data, list):
+                                for item in msg_data:
                                     await self._process_kalshi_message(item)
                                     await self._notify_price("kalshi", item)
                             else:
-                                await self._process_kalshi_message(data)
-                                await self._notify_price("kalshi", data)
+                                await self._process_kalshi_message(msg_data)
+                                await self._notify_price("kalshi", msg_data)
                             
                         except Exception as e:
                             # Catch all to prevent disconnect on bad message format
@@ -186,24 +205,36 @@ class LiveEngine:
     async def _process_kalshi_message(self, data: Dict):
         msg_type = data.get("type", "")
         
-        if msg_type == "trade" or msg_type == "orderbook":
-            ticker = data.get("ticker") or data.get("market_ticker")
+        if msg_type in ["trade", "ticker"]:
+            ticker = data.get("market_ticker")
             if not ticker:
                 return
                 
             price = 0.0
             volume = 0
             
-            if msg_type == "trade":
-                price = data.get("price", 0) / 100 if isinstance(data.get("price"), (int, float)) else 0
-                volume = data.get("size", 0) or data.get("volume", 0)
-            elif msg_type == "orderbook":
-                orderbook = data.get("orderbook", {})
-                yes_orders = orderbook.get("yes", [])
-                if yes_orders and len(yes_orders) > 0:
-                    price = yes_orders[0][0] / 100 if isinstance(yes_orders[0][0], (int, float)) else 0
+            try:
+                if msg_type == "ticker":
+                    yes_bid = data.get("yes_bid")
+                    yes_ask = data.get("yes_ask")
+                    if yes_bid and yes_ask:
+                        price = (float(yes_bid) + float(yes_ask)) / 2 / 100
+                    elif yes_bid:
+                        price = float(yes_bid) / 100
+                    volume = int(data.get("volume", 0) or 0)
+                elif msg_type == "trade":
+                    price = float(data.get("price", 0)) / 100
+                    volume = int(data.get("size", 0) or data.get("volume", 0))
+            except (ValueError, TypeError):
+                pass
                     
-            await self.store.update_from_kalshi(ticker, price, volume)
+            if ticker and price > 0:
+                await self.store.update_from_kalshi(ticker, price, volume)
+        
+        elif msg_type == "fill":
+            logger.info(f"Private Fill: {data}")
+        elif msg_type == "order":
+            logger.info(f"Private Order: {data}")
             
         elif msg_type == "heartbeat":
             self.kalshi_status.last_heartbeat = time.time()
@@ -232,15 +263,14 @@ class LiveEngine:
                             logger.error(f"Failed to fetch Poly markets: {e}")
                             
                     if not token_ids:
-                        # Fallback static token for testing if fetch fails (e.g. some active token id)
-                        token_ids = ["59441160358925232801458852870404391219089069695648877112104523996766487955513"] # Trump 2024 token id approx
-                            
+                        token_ids = [""] 
+                    
                     sub_msg = {
                         "type": "market",
                         "operation": "subscribe",
-                        "assets_ids": token_ids[:100]  # Subscribe to up to 100 active tokens
+                        "assets_ids": token_ids[:50] if token_ids else [],
                     }
-                    logger.debug(f"Subscribing to Poly with {len(token_ids[:100])} tokens.")
+                    logger.info(f"Subscribing to Poly market data")
                     await ws.send(json.dumps(sub_msg))
                     
                     async for message in ws:
@@ -248,12 +278,21 @@ class LiveEngine:
                             break
                             
                         try:
+                            # Handle bytes message
+                            if isinstance(message, bytes):
+                                message = message.decode('utf-8')
+                            
                             # Forward raw message
                             await self._notify_raw("polymarket", message)
                             
                             data = json.loads(message)
                             self.poly_status.messages_received += 1
                             
+                            # Skip pings
+                            if data.get("type") == "ping":
+                                await ws.send(json.dumps({"type": "pong"}))
+                                continue
+                            
                             if isinstance(data, list):
                                 for item in data:
                                     await self._process_poly_message(item)
@@ -324,6 +363,71 @@ class LiveEngine:
         if not self._http_client:
             self._http_client = httpx.AsyncClient(timeout=30.0)
             
+        logger.info("Fetching initial markets...")
+        
+        # 1. Fetch from Kalshi
+        kalshi_markets = []
+        if self.kalshi_client:
+            try:
+                kalshi_markets = await self.kalshi_client.get_active_markets(limit=50)
+                for m in kalshi_markets:
+                    price = 0
+                    if self.kalshi_client.use_mock:
+                        price = m.last_price 
+                    else:
+                        yes_bid = m.yes_bid or 0
+                        yes_ask = m.yes_ask or 0
+                        if yes_bid > 0 and yes_ask > 0:
+                            price = (yes_bid + yes_ask) / 2 / 100
+                        elif yes_bid > 0:
+                            price = yes_bid / 100
+                        elif yes_ask > 0:
+                            price = yes_ask / 100
+                    
+                    if price > 0:
+                        await self.store.update_from_kalshi(m.ticker, price, 0)
+                logger.info(f"Fetched {len(kalshi_markets)} markets from Kalshi.")
+            except Exception as e:
+                logger.error(f"Failed to fetch Kalshi markets: {e}")
+        
+        # 2. Fetch from Polymarket
+        try:
+            response = await self._http_client.get(
+                f"{self.POLY_GAMMA_API}/markets",
+                params={"active": "true", "limit": 50, "closed": "false"}
+            )
+            if response.status_code == 200:
+                poly_markets = response.json()
+                for m in poly_markets:
+                    outcome_prices_raw = m.get('outcomePrices')
+                    price = 0
+                    if outcome_prices_raw:
+                        try:
+                            if isinstance(outcome_prices_raw, str):
+                                outcome_prices = json.loads(outcome_prices_raw)
+                            else:
+                                outcome_prices = outcome_prices_raw
+                            if outcome_prices and len(outcome_prices) > 0:
+                                price = float(outcome_prices[0])
+                        except (ValueError, TypeError, json.JSONDecodeError):
+                            price = 0
+                    
+                    token_id = None
+                    clob_token_ids = m.get('clobTokenIds', [])
+                    if clob_token_ids and len(clob_token_ids) > 0:
+                        token_id = clob_token_ids[0]
+                    
+                    if price > 0 and token_id:
+                        await self.store.update_from_poly(
+                            token_id, 
+                            m.get('question'), 
+                            price, 
+                            0
+                        )
+                logger.info(f"Fetched {len(poly_markets)} markets from Polymarket.")
+        except Exception as e:
+            logger.error(f"Failed to fetch Polymarket markets: {e}")
+            
         return True
         
     def get_status_summary(self) -> Dict[str, Any]:
diff --git a/requirements.txt b/requirements.txt
index b7cea84..a68e639 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -6,4 +6,3 @@ numpy>=2.0.0
 httpx>=0.28.0
 websockets>=11.0.0
 rapidfuzz>=3.0.0
-anthropic>=0.18.0
diff --git a/unified_terminal.py b/unified_terminal.py
index e4c73ab..2581a19 100644
--- a/unified_terminal.py
+++ b/unified_terminal.py
@@ -24,39 +24,119 @@ from live_engine import LiveEngine
 from unified_store import UnifiedStore
 from agent_manager import AgentManager
 
-# Configure logging to hide noise
 logging.basicConfig(level=logging.ERROR)
 logger = logging.getLogger("UnifiedTerminal")
 
-class BloombergTicker(Static):
-    """Sleek top ticker for market indices/status."""
+class StatusTicker(Static):
     def on_mount(self):
         self.set_interval(2, self.update_ticker)
         self.update_ticker()
 
     def update_ticker(self):
         now = datetime.now().strftime("%H:%M:%S")
+        env = self.app.engine.kalshi_env.upper()
+        k = self.app.engine.kalshi_status
+        p = self.app.engine.poly_status
+        
+        k_icon = "[green]â—[/]" if k.connected else "[red]â—‹[/]"
+        p_icon = "[green]â—[/]" if p.connected else "[red]â—‹[/]"
+        
+        k_msg = k.messages_received
+        p_msg = p.messages_received
+        
         self.update(
-            f" [bold cyan]LIVE STREAM[/] | KALSHI: [green]DEMO[/] | POLY: [green]ACTIVE[/] | "
-            f"DXY: 104.20 (-0.05%) | BTC: 67,890 (+2.34%) | {now} "
+            f" [bold #58a6ff]â—ˆ[/] [bold]MARKET TERMINAL[/] â”‚ KALSHI: {k_icon} {k_msg} â”‚ POLY: {p_icon} {p_msg} â”‚ {env} â”‚ {now} "
         )
 
-class ClawdbotStatus(Static):
-    """Dynamic status bar for the AI agent."""
-    message = reactive("[Clawdbot v1.0] Ready and monitoring...")
+class MarketDetail(Static):
+    def on_mount(self):
+        self.update_detail(None)
+    
+    def update_detail(self, market):
+        if market is None:
+            self.update("[dim]Select a market to view details[/dim]")
+            return
+        
+        k_price = f"${market.kalshi_price:.2f}" if market.kalshi_price > 0 else "[dim]-[/]"
+        p_price = f"${market.poly_price:.2f}" if market.poly_price > 0 else "[dim]-[/]"
+        
+        spread = "-"
+        if market.has_both_prices:
+            s_val = market.delta_percent
+            color = "green" if s_val > 0 else "red"
+            spread = f"[{color}]{s_val:+.1f}%[/]"
+        
+        vol = self.app.format_volume(market.total_volume)
+        
+        detail = f"""[bold cyan]{market.event_name[:45]}[/]
+
+[yellow]Kalshi:[/] {k_price}
+[magenta]Poly:[/]   {p_price}
+[yellow]Î”:[/]      {spread}
+[blue]Volume:[/]   {vol}
 
+[dim]ID:[/] {market.id[:30]}..."""
+        
+        if market.kalshi_ticker:
+            detail += f"\n[dim]Ticker:[/] {market.kalshi_ticker}"
+        
+        self.update(detail)
+
+class PriceSparkline(Static):
+    def on_mount(self):
+        self.set_interval(1, self.update_sparkline)
+    
+    def update_sparkline(self):
+        if not hasattr(self.app, 'selected_market') or not self.app.selected_market:
+            self.update("")
+            return
+        
+        history = self.app.store.get_price_history(self.app.selected_market)
+        if not history:
+            self.update("")
+            return
+        
+        prices = []
+        for p in history[-30:]:
+            if p.kalshi_price:
+                prices.append(p.kalshi_price)
+            if p.poly_price:
+                prices.append(p.poly_price)
+        
+        if len(prices) < 2:
+            self.update("")
+            return
+        
+        min_p = min(prices)
+        max_p = max(prices)
+        if max_p == min_p:
+            norm = [50] * len(prices)
+        else:
+            norm = [int(((x - min_p) / (max_p - min_p)) * 100) for x in prices]
+        
+        self.update(f"[dim]Price:[/] {' '.join('â–â–‚â–ƒâ–„â–…â–†â–‡â–ˆ'[min(7, p // 12)] for p in norm)}")
+
+
+class AgentStatus(Static):
+    message = reactive("[cyan]Clawdbot[/] Ready")
+    
     def render(self) -> str:
-        return f" ðŸ¦ž {self.message}"
+        return f" {self.message}"
+
 
 class UnifiedTerminal(App):
     CSS_PATH = "unified_terminal.tcss"
     
     BINDINGS = [
         Binding("q", "quit", "Quit"),
-        Binding("r", "refresh", "Refresh Markets"),
-        Binding("c", "clear_logs", "Clear Logs"),
-        Binding("t", "toggle_logs", "Toggle WebSockets"),
-        Binding("ctrl+l", "focus_input", "Clawdbot CMD"),
+        Binding("r", "refresh_markets", "Refresh"),
+        Binding("c", "clear_logs", "Clear"),
+        Binding("t", "toggle_logs", "Toggle Feed"),
+        Binding("ctrl+l", "focus_input", "Command"),
+        Binding("up", "cursor_up", "Up"),
+        Binding("down", "cursor_down", "Down"),
+        Binding("enter", "select_market", "Select"),
+        Binding("escape", "clear_selection", "Back"),
     ]
 
     def __init__(self):
@@ -64,12 +144,12 @@ class UnifiedTerminal(App):
         self.store = UnifiedStore()
         self.kalshi = KalshiClient()
         
-        # Initialize engines
         self.engine = LiveEngine(
             store=self.store,
             kalshi_env=os.getenv("KALSHI_ENV", "demo"),
             kalshi_api_key=os.getenv("KALSHI_API_KEY"),
-            kalshi_private_key=self.kalshi.private_key_content if not self.kalshi.use_mock else None
+            kalshi_private_key=self.kalshi.private_key_content if not self.kalshi.use_mock else None,
+            kalshi_client=self.kalshi
         )
         
         self.agent = AgentManager(
@@ -78,53 +158,51 @@ class UnifiedTerminal(App):
         )
         
         self.show_logs = True
-        self.market_map = {} # row_index -> market_id
+        self.market_map = {}
+        self.selected_market = None
 
     def compose(self) -> ComposeResult:
-        yield BloombergTicker(id="ticker")
+        yield StatusTicker(id="ticker")
         
         with Horizontal(id="main-area"):
-            with Vertical(id="market-pane"):
-                yield Label(" [bold underline]MARKET MONITOR[/]", classes="pane-title")
+            with Vertical(id="market-pane", classes="pane"):
+                yield Label(" MARKET MONITOR ", classes="pane-title")
                 yield DataTable(id="market-table")
             
-            with Vertical(id="sidebar"):
-                with Vertical(id="websocket-pane"):
-                    yield Label(" [bold underline]WEBSOCKET FEEDS[/]", classes="pane-title")
-                    yield RichLog(id="ws-log", highlight=True, wrap=True, max_lines=500)
-                
-                with Vertical(id="agent-pane"):
-                    yield Label(" [bold underline]CLAWDBOT TERMINAL[/]", classes="pane-title")
-                    yield RichLog(id="agent-output", highlight=True, wrap=True)
-                    yield Input(placeholder="Ask Clawdbot... (e.g. /analyze)", id="agent-input")
-        
-        yield ClawdbotStatus(id="status-bar")
+            with Vertical(id="detail-pane", classes="pane"):
+                yield Label(" MARKET DETAIL ", classes="pane-title")
+                yield MarketDetail(id="market-detail")
+                yield PriceSparkline(id="price-spark")
+            
+            with Vertical(id="sidebar", classes="pane"):
+                yield Label(" CLAWDBOT ", classes="pane-title")
+                yield RichLog(id="agent-output", highlight=True, wrap=True, max_lines=20)
+                yield Input(placeholder="Type command...", id="agent-input", classes="cmd-input")
+        
+        yield AgentStatus(id="status-bar")
         yield Footer()
 
     async def on_mount(self) -> None:
         table = self.query_one("#market-table", DataTable)
-        table.add_columns("Market", "Kalshi", "Poly", "Î”%", "Vol")
+        table.add_columns("Market", "Kalshi", "Poly", "Spread", "Vol")
         table.cursor_type = "row"
+        table.row_height = 1
         
-        # Connect to store updates
         self.store.subscribe(self._on_store_update)
-        
-        # Connect to raw websocket feeds
         self.engine.add_raw_callback(self._on_raw_ws)
-        
-        # Connect agent output
         self.agent.add_output_callback(self._on_agent_output)
         
-        # Start background engines
         self.start_engines()
 
     @work
     async def start_engines(self):
+        await self.engine.fetch_initial_markets()
         await self.engine.start()
         await self.agent.start()
+        self.query_one("#agent-output").write("[dim]Clawdbot initialized. Type /help for commands.[/]")
 
     def _on_store_update(self, market, change_type):
-        if change_type == 'rebuild_complete' or change_type == 'new_market' or change_type in ['kalshi_update', 'poly_update']:
+        if change_type in ['rebuild_complete', 'new_market', 'kalshi_update', 'poly_update']:
             self.call_from_thread(self.update_market_table)
 
     def update_market_table(self):
@@ -132,32 +210,28 @@ class UnifiedTerminal(App):
         markets = self.store.get_all_markets()
         markets.sort(key=lambda x: x.total_volume, reverse=True)
         
-        # Efficient update: try to update existing rows or rebuild if needed
-        # For simplicity in this version, we clear and repopulate
-        # A more performant way would be to track row keys
         table.clear()
         self.market_map = {}
         
         for i, m in enumerate(markets):
-            k_price = f"{m.kalshi_price:.2f}" if m.kalshi_price > 0 else "-"
-            p_price = f"{m.poly_price:.2f}" if m.poly_price > 0 else "-"
+            k_price = f"${m.kalshi_price:.2f}" if m.kalshi_price > 0 else "-"
+            p_price = f"${m.poly_price:.2f}" if m.poly_price > 0 else "-"
             
-            delta = "-"
+            spread = "[dim]-[/]"
             if m.has_both_prices:
-                d_val = m.delta_percent
-                color = "green" if d_val > 0 else "red"
-                delta = f"[{color}]{d_val:+.1f}%[/]"
+                s_val = m.delta_percent
+                color = "green" if s_val > 0 else "red"
+                spread = f"[{color}]{s_val:+.1f}%[/]"
             
             vol = self.format_volume(m.total_volume)
             
-            # Simple icon for status
-            status = "â—" if m.has_both_prices else "â—‹"
+            icon = "â—‰" if m.has_both_prices else "â—‹"
             
             table.add_row(
-                f"{status} {m.event_name[:35]}",
+                f"{icon} {m.event_name[:32]}",
                 k_price,
                 p_price,
-                delta,
+                spread,
                 vol
             )
             self.market_map[i] = m.id
@@ -169,48 +243,88 @@ class UnifiedTerminal(App):
 
     def _on_raw_ws(self, platform, message):
         try:
+            ws_log = self.query_one("#agent-output")
             data = json.loads(message)
             msg_type = data.get('type', 'data')
-            if msg_type == 'heartbeat': return # skip noise
+            if msg_type in ['heartbeat', 'subscribed']: 
+                return
             
             color = "cyan" if platform == "kalshi" else "magenta"
-            formatted = f"[{color}]{platform.upper()}[/] | {msg_type} | {str(data)[:80]}..."
+            preview = str(data)[:50].replace('\n', ' ')
+            formatted = f"[{color}]{platform[:4].upper()}[/] {msg_type[:12]} {preview}..."
             
-            self.call_from_thread(self.query_one("#ws-log").write, formatted)
+            self.call_from_thread(ws_log.write, formatted)
         except Exception:
             pass
 
     async def _on_agent_output(self, text, style="default"):
-        color = "white"
-        if style == "success": color = "green"
-        elif style == "warning": color = "yellow"
-        elif style == "error": color = "red"
-        elif style == "user": color = "cyan"
-        elif style == "assistant": color = "bright_blue"
+        colors = {
+            "default": "white",
+            "success": "green",
+            "warning": "yellow", 
+            "error": "red",
+            "user": "cyan",
+            "assistant": "bright_blue",
+            "system": "dim"
+        }
+        color = colors.get(style, "white")
         
-        self.call_from_thread(self.query_one("#agent-output").write, f"[{color}]{text}[/]")
+        self.call_from_thread(
+            self.query_one("#agent-output").write, 
+            f"[{color}]{text}[/]"
+        )
 
     async def on_input_submitted(self, event: Input.Submitted):
         if event.input.id == "agent-input":
             cmd = event.input.value.strip()
             event.input.value = ""
-            if not cmd: return
+            if not cmd:
+                return
             
-            # Use task to process without blocking UI
+            self.query_one("#agent-output").write(f"[cyan]>[/] {cmd}")
             self.run_worker(self.agent.process_message(cmd))
 
+    def action_cursor_up(self):
+        table = self.query_one("#market-table", DataTable)
+        table.action_cursor_up()
+        self.update_selection()
+
+    def action_cursor_down(self):
+        table = self.query_one("#market-table", DataTable)
+        table.action_cursor_down()
+        self.update_selection()
+
+    def action_select_market(self):
+        table = self.query_one("#market-table", DataTable)
+        cursor = table.cursor_row
+        if cursor in self.market_map:
+            self.selected_market = self.market_map[cursor]
+            market = self.store.get_market(self.selected_market)
+            self.query_one("#market-detail").update_detail(market)
+
+    def action_clear_selection(self):
+        self.selected_market = None
+        self.query_one("#market-detail").update_detail(None)
+
+    def update_selection(self):
+        table = self.query_one("#market-table", DataTable)
+        cursor = table.cursor_row
+        if cursor in self.market_map:
+            mid = self.market_map[cursor]
+            market = self.store.get_market(mid)
+            if market:
+                self.query_one("#market-detail").update_detail(market)
+
     def action_toggle_logs(self):
         self.show_logs = not self.show_logs
-        sidebar = self.query_one("#websocket-pane")
-        sidebar.display = self.show_logs
+        pane = self.query_one("#detail-pane")
+        pane.display = self.show_logs
 
     def action_clear_logs(self):
-        self.query_one("#ws-log").clear()
         self.query_one("#agent-output").clear()
 
-    def action_refresh(self):
-        # Trigger an engine poll or refresh if needed
-        pass
+    def action_refresh_markets(self):
+        self.run_worker(self.engine.fetch_initial_markets())
 
     def action_focus_input(self):
         self.query_one("#agent-input").focus()
diff --git a/unified_terminal.tcss b/unified_terminal.tcss
index a303c65..5d60aef 100644
--- a/unified_terminal.tcss
+++ b/unified_terminal.tcss
@@ -1,16 +1,15 @@
-/* Unified Terminal Bloomberg Style CSS */
+/* Unified Terminal - Professional Dark Theme */
 
 Screen {
-    background: #000000;
-    color: #ffffff;
-    font-family: "Courier New", Courier, monospace;
+    background: #0d1117;
+    color: #c9d1d9;
 }
 
 #ticker {
     dock: top;
     height: 1;
-    background: #000080;
-    color: #ffffff;
+    background: #161b22;
+    color: #c9d1d9;
     padding: 0 1;
     text-style: bold;
 }
@@ -19,78 +18,95 @@ Screen {
     height: 1fr;
 }
 
-#market-pane {
-    width: 60%;
-    border-right: solid #333333;
-    padding: 0 1;
+.pane {
+    border: none;
 }
 
-#sidebar {
-    width: 40%;
+#market-pane {
+    width: 50%;
+    border-right: solid #30363d;
 }
 
-#websocket-pane {
-    height: 30%;
-    border-bottom: solid #333333;
-    padding: 0 1;
+#detail-pane {
+    width: 25%;
+    border-right: solid #30363d;
 }
 
-#agent-pane {
-    height: 70%;
-    padding: 0 1;
+#sidebar {
+    width: 25%;
 }
 
 .pane-title {
-    background: #111111;
-    color: #ff9900;
-    margin-bottom: 0;
+    background: #161b22;
+    color: #f0883e;
     padding: 0 1;
     text-align: center;
+    text-style: bold;
 }
 
 #market-table {
     height: 1fr;
-    background: #000000;
+    background: #0d1117;
     border: none;
 }
 
 DataTable > .datatable--header {
-    background: #1a1a1a;
-    color: #00ffff;
+    background: #21262d;
+    color: #58a6ff;
     text-style: bold;
 }
 
 DataTable > .datatable--cursor {
-    background: #222222;
+    background: #1f6feb;
+    color: #ffffff;
+}
+
+DataTable {
+    color: #c9d1d9;
+}
+
+#market-detail {
+    height: 12;
+    padding: 1;
+    background: #0d1117;
+    color: #c9d1d9;
+    content-align: left top;
 }
 
-#ws-log {
-    background: #050505;
-    color: #aaaaaa;
+#price-spark {
+    height: 1;
+    padding: 0 1;
+    background: #0d1117;
+    color: #8b949e;
 }
 
 #agent-output {
-    background: #050505;
-    color: #eeeeee;
     height: 1fr;
+    background: #0d1117;
+    color: #c9d1d9;
+    padding: 0;
 }
 
 #agent-input {
-    background: #111111;
-    color: #00ff00;
+    background: #21262d;
+    color: #3fb950;
     border: none;
-    margin: 0;
+    padding: 0 1;
+}
+
+#agent-input:focus {
+    background: #21262d;
 }
 
 #status-bar {
     dock: bottom;
     height: 1;
-    background: #1a1a1a;
-    color: #cccccc;
+    background: #161b22;
+    color: #8b949e;
     padding: 0 1;
 }
 
 Footer {
-    background: #000000;
-    color: #fab387;
+    background: #0d1117;
+    color: #f0883e;
 }
